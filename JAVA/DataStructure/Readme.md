# 자료구조는 근본적으로 무엇인가를 '표현'하는 도구. 
  표현을 위해서 저장과 삭제라는 기능이 제공되는 것으로 이해하는 것이 옳다.

## 탐색 
* 순차 탐색 = 맨 앞에서부터 순서대로 탐색을 진행하는 알고리즘
* 이진 탐색 = 탐색의 대상을 반복해서 반씩 떨구어 내는 알고리즘(이진 탐색 조건: 정렬되어 있어야 함)
* 재귀 = 함수 내에서 자기 자신을 다시 호출하는 함수를 의미
* 추상 자료형(Abstract Data Type. ADT) = 구체적인 기능의 완성 과정을 언급하지 않고, 순수하게 기능이 무엇인지 나열한 것 (기능들의 연속)

## 시간 복잡도

최악의 경우를 시간 복잡도의 기준으로 삼는다. (평균적인 경우는 각 알고리즘마다 가정을 설정하기 어렵고 객관적인 판단이 어렵기 때문)

O(1) < O(logn) < o(n) < o(nlogn) < o(n2) < o(n3) < o(2의 n승)

![시간 복잡도 표](./image.png)

O(1) : 입력 데이터의 크기와 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 말한다. (Constant Time)

입력되는 데이터양과 상관없이 일정한 실행 시간을 가진다.
알고리즘이 문제를 해결하는데 오직 한 단계만 거친다.

O(n) : 입력 데이터의 크기에 비례해서 처리시간에 걸리는 알고리즘을 표현할 때 사용 (Linear Time)

데이터양에 따라 시간이 정비례한다.
Linear search, for 문을 통한 탐색을 생각하면 된다.

O(n^2) : Quadratic Time

데이터양에 따라 걸리는 시간은 제곱에 비례한다. (효율이 좋지 않음, 사용 X)
해당 유형은 이중 Loop내에서 입력 자료를 처리 하는 경우에 나타난다. N값이 큰 값이 되면 실행 시간은 감당하지 못할 정도로 커지게 될 것이다.
문제를 해결하기 위한 단계의 수는 입력값 n의 제곱

O(log n) : Binary search tree access(이진 검색) - search(검색), insertion(삽입), deletion(삭제)

데이터양이 많아져도, 시간이 조금씩 늘어난다.
시간에 비례하여, 탐색 가능한 데이터양이 2의 n승이 된다.
문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.
만약 입력 자료의 수에 따라 실행 시간이 이 log N의 관계를 만족한다면 N이 증가함에 따라 실행시간이 조금씩 늘어난다. 주로 커다란 문제를 일정한 크기를 갖는 작은 문제로 쪼갤때 나타나는 유형이다.

## 자료구조

### Array 
Array는 논리적 순서와 물리적 순서가 일치하여, index값을 통한 원소 접근이 용이하고 구현이 쉽다. 

단점 
1. 삽입, 삭제 등에 대한 연산에 필요한 Cost가 높다.

삭제->삭제한 인덱스 뒤의 원소들을 모두 앞으로 Shift연산, 삽입-> 삽입한 인덱스 포함, 그 뒤의 인덱스들에 Shift 연산을 해줘야 한다. 

2. 배열은 정의와 동시에 길이를 지정하며 길이를 바꿀 수 없고, 배열에서 설정된 엘리먼트의 개수를 알아낼 수 없다.
3. 기능이 없다.
4. 데이터에 대한 인덱스 값이 고정되어야 한다.(삭제된 엘리먼트의 공간이 그대로 남아 메모리 낭비)

#### 인덱스가 중요한 경우는 배열을 사용, 인덱스가 중요하지 않은 경우에는 리스트를 사용한다.

* 배열의 삽입/삭제 연산에 대한 비효율성을 극복하고자 등장한 것이 LinkedList 이다. 
  Array와 LinkedList의 차이점은, LinkedList는 논리적으론 순서대로 되어있으나 물리적으론 순서대로 되어있지 않다. 
  대신 LinkedList는 각 원소가 다음 index 위치에 해당하는 물리적 주소를 가지고 있다. 그렇기에 삽입/삭제시에는 데이터를 Shift할 필요 없이, 해당되는 원소의 물리적 주소만 변경해주면 된다. 
  하지만 이 같은 특징 때문에 원하는 index를 참조하려면, 1번 index부터 차례대로 접근해야 한다는 비효율성이 있다.
  
 ### List
 
